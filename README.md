# kafka-starter

### 파티션

- 자료구조에서 접하는 큐와 비슷한 구조
- FIFO구조와 같이 먼저 들어간 레코드는 컨슈머가 먼저 가져간다.
- 하지만 일반적인 큐는 데이터를 가져가면(pop) 레코드를 삭제하지만, `카프카에서는 삭제하지 않는다`
- 이러한 특징 때문에 레코드는 다양한 목적으로 가진 여러 컨슈머 그룹들이 토픽의 데이터를 `여러번 가져갈 수 있다.`

### 토픽 네이밍 규칙

<img width="687" alt="image" src="https://user-images.githubusercontent.com/76584547/180654328-59a7692b-677b-4478-83e3-43cdbd872f16.png">

<img width="690" alt="image" src="https://user-images.githubusercontent.com/76584547/180654334-2da7f3ce-1f29-4102-9dbe-19484961e8fc.png">

### 레코드

- 레코드는 타임스탬프, 메시지 키, 메시지 값, 오프셋, 헤더로 구성
- 프로듀서가 생성한 레코드가 브로커로 전송되면 오프셋과 타임스탬프가 지정
- 브로커에 한 번 적재된 레코드는 수정할 수 없고 로그 리텐션 기간 또는 용량에 따라서만 사게된다
- 타임스탬프는 프로듀서가 해당 레코드를 생성한 시점의 유닉스 타임으로 설정된다.
- 컨슈머는 레코드의 타임스탬프를 토대로 레코드가 언제 생성됐는지 확인
- 다만, 타임스탬프가 `토픽 설정에 따라 브로커에 적재된 시간으로 설정`될 수도 있다는 점을 유의해야한다.
- 메시지 키
    - 메시지 키를 사용하면 프로듀서가 토픽에 레코드를 전송할 때 메시지 키의 해시 값을 토대로 파티션을 지정
    - 즉, `동일한 메시키 지라면 동일 파티션에 들어간다`
    - 다만, `어느 파티션에 지정될지 알 수 없고` 파티션 개수가 변경되면 메시지 키와 파티션 매칭이 달리지게 되므로 주의해야한다.
    - 메시지 키를 설정하지 않으면 null로 설정되어서 프로듀서 기본 설저 파티셔너에 따라서 파티션에 분배돼서 적재
- 직렬화, 역직렬화
    - 메시지 키와 메시지 값은 직렬화되어 브로커로 전송되기 때문에 컨슈머가 이용할 때는 직렬화한 형태와 동일한 형태로 역직렬화를 수행해야한다.
- 오프셋
    - 0 이상의 숫자로 이루어져 있다.
    - 오프셋은 직접 지정할 수 없고, 브로커에 저장될 때 이전에 전송된 레코드의 오프셋 +1값으로 생성
    - 오프셋을 사용하면 컨슈머 그룹으로 이루어진 카프카 컨슈머들이 파티션의 데이터를 어디까지 가져갔는지 명확히 지정할 수 있다.
- 헤더
    - 레코드의 추가적인 정보를 담는 메타데이터 저장소 용도로 사용한다.
    - 헤더는 키/값 형티로 데이터를 추가하여 레코드의 속성(스키마 버전 등)ㅇ르 저장하여 컨슈머에서 참조할 수 있다.
